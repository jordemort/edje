.TH "edcref" 3 "25 Sep 2008" "Edje" \" -*- nroff -*-
.ad l
.nh
.SH NAME
edcref \- Edje Data Collection reference 
An Edje Data Collection, it's a plain text file (normally identified with the .edc extension),consisting of instructions for the Edje Compiler.
.PP
The syntax for the edje data collection files follows a simple structure of 'blocks { .. }' that can contain 'properties: ..', more blocks, or both.
.PP
\fBAuthor:\fP
.RS 4
Andres Blanc (dresb) andresblanc@gmail.com
.RE
.PP
\fB images \fP
.PP
.PP
.nf
        images {
            image: 'filename1.ext' COMP;
            image: 'filename2.ext' LOSSY 99;
            ..
        }
.fi
.PP
 The 'images' block is used to list each image file that will be used in the theme along with its compression method (if any). Besides the domcument's root, additional 'images' blocks can be included inside other blocks, normally 'collections', 'group' and 'part', easing mantienance of the file list when the theme is split among multiple files. 
.PP
 \fC image \fP\fC [image file] [compression method] (compression level) \fP Used to include each image file. The full path to the directory holding the images can be defined later with edje_cc's '-id' option. Compression methods: 
.PD 0

.IP "\(bu" 2
RAW: Uncompressed. 
.IP "\(bu" 2
COMP: Lossless compression. 
.IP "\(bu" 2
LOSSY [0-100]: Lossy comression with quality from 0 to 100. 
.PP
.PP
\fB fonts \fP
.PP
.PP
.nf
        fonts {
            font: 'filename1.ext' 'fontname';
            font: 'filename2.ext' 'otherfontname';
            ..
        }
.fi
.PP
 The 'fonts' block is used to list each font file with an alias used later in the theme. As with the 'images' block, additional 'fonts' blocks can be included inside other blocks. 
.PP
 \fC font \fP\fC [font filename] [font alias] \fP Defines each font 'file' and 'alias', the full path to the directory holding the font files can be defined with edje_cc's '-fd' option. 
.PP
\fB data \fP
.PP
.PP
.nf
        data {
            item: 'arbitraryname' 'arbitraryvalue';
            item: 'othername' 'othervalue';
            ..
        }
.fi
.PP
 The 'data' block is used to pass arbitrary parameters from the theme to the application. Unlike the 'images' and 'fonts' blocks, additional 'data' blocks can only be included inside the 'group' block. 
.PP
 \fC item \fP\fC [parameter name] [parameter value] \fP Defines each additional parameter. 
.PP
\fB data \fP
.PP
.PP
.nf
        data {
            file: 'arbitraryname' 'filename';
            file: 'othername' 'otherfilename';
            ..
        }
.fi
.PP
 The 'data' block is used to pass arbitrary parameters from the theme to the application. Unlike the 'images' and 'fonts' blocks, additional 'data' blocks can only be included inside the 'group' block. 
.PP
 \fC file \fP\fC [parameter name] [parameter filename] \fP Defines each additional parameter. 
.PP
\fB color_classes \fP
.PP
.PP
.nf
        color_classes {
            color_class {
                name:  'colorclassname';
                color:  [0-255] [0-255] [0-255] [0-255];
                color2: [0-255] [0-255] [0-255] [0-255];
                color3: [0-255] [0-255] [0-255] [0-255]
            }
            ..
        }
.fi
.PP
 The 'color_classes' block contains a list of one or more 'color_class' blocks. Each 'color_class' allows the designer to name an arbitrary group of colors to be used in the theme, the application can use that name to alter the color values at runtime. 
.PP
 
.PP
\fC name \fP\fC [color class name] \fP Sets the name for the color class, used as reference by both the theme and the application. 
.PP
 
.PP
\fC color \fP\fC [red] [green] [blue] [alpha] \fP The main color. 
.PP
 
.PP
\fC color2 \fP\fC [red] [green] [blue] [alpha] \fP Used as shadow in text and textblock parts. 
.PP
 
.PP
\fC color3 \fP\fC [red] [green] [blue] [alpha] \fP Used as outline in text and textblock parts. 
.PP
\fB spectra \fP
.PP
.PP
.nf
        spectra {
            spectrum {
                name: 'colorspectrumname';
                color: [0-255] [0-255] [0-255] [0-255] [0-?]
                color: [0-255] [0-255] [0-255] [0-255] [0-?]
                ..
            }
            ..
        }
.fi
.PP
 The 'spectra' block contains a list of one or more 'spectrum' blocks. Each 'spectrum' block defines a color range used to fill GRADIENT parts. The colors are defined with the red, green, blue, alpha, delta format. 
.PP
 
.PP
\fC name \fP\fC [spectrum name] \fP The name of the spectrum used as reference later in the theme. 
.PP
 
.PP
\fC color \fP\fC [red] [green] [blue] [alpha] [delta] \fP Each color declaration represents a stop point in the color range. The last parameter (delta) is used to set the proportion of a given stop point higher or lower in contrast with the other color's delta value. 
.PP
\fB styles \fP
.PP
.PP
.nf
        styles {
            style {
                name: 'stylename';
                base: '..default style properties..';

                tag:  'tagname' '..style properties..';
                ..
            }
            ..
        }
.fi
.PP
 The 'styles' block contains a list of one or more 'style' blocks. A 'style' block is used to create style <tags> for advanced TEXTBLOCK formatting. 
.PP
 
.PP
\fC name \fP\fC [style name] \fP The name of the style to be used as reference later in the theme. 
.PP
 
.PP
\fC base \fP\fC [style properties string] \fP The default style properties that will be applied to the complete text. 
.PP
 
.PP
\fC tag \fP\fC [tag name] [style properties string] \fP Style to be applied only to text between style <tags>..</tags>. 
.PP
\fB collections \fP
.PP
.PP
.nf
        collections {
            ..
            group { }
            group { }
            ..
        }
.fi
.PP
 The 'collections' block is used to list the groups that compose the theme. Additional 'collections' blocks do not prevent overriding group names. 
.PP
\fB group \fP
.PP
.PP
.nf
        collections {
            ..
            group {
                name: 'nameusedbytheapplication';
                alias: 'anothername';
                min: width height;
                max: width height;

                data { }
                script { }
                parts { }
                programs { }
            }
            ..
        }
.fi
.PP
 A 'group' block contains the list of parts and programs that compose a given Edje Object. 
.PP
 
.PP
\fC name \fP\fC [group name] \fP The name that will be used by the application to load the resulting Edje object, must be unique within the theme. 
.PP
 
.PP
\fC script_only \fP\fC [on/off] \fP The flag (on/off) as to if this group is defined ONLY by script callbacks such as init(), resize() and shutdown() 
.PP
 
.PP
\fC alias \fP\fC [aditional group name] \fP Additional name to serve as identifier. Defining multiple aliases is supported. 
.PP
 
.PP
\fC min \fP\fC [width] [height] \fP The minimum size for the container defined by the composition of the parts. 
.PP
 
.PP
\fC max \fP\fC [width] [height] \fP The maximum size for the container defined by the totality of the parts. 
.PP
\fB script \fP
.PP
.PP
.nf
        ..
        group {
            script {
                //embryo script
            }
            ..
            program {
                script {
                    //embryo script
                }
            }
            ..
        }
        ..
.fi
.PP
 This block is used to 'inject' embryo scripts to a given Edje theme and it functions in two modalities. When it's included inside a 'program' block, the script will be executed every time the program is run, on the other hand, when included directly into a 'group', 'part' or 'description' block, it will be executed once at load time, in the load order. 
.PP
\fB part \fP
.PP
.PP
.nf
        group {
            parts {
                ..
                part {
                    name: 'partname';
                    type: IMAGE;
                    mouse_events:  1;
                    repeat_events: 0;
                    ignore_flags: NONE;
                    clip_to: 'anotherpart';
                    source:  'groupname';
                    pointer_mode: AUTOGRAB;
                    use_alternate_font_metrics: 0;

                    description { }
                    dragable { }
                }
                ..
            }
        }
.fi
.PP
 Parts are used to represent the most basic design elements of the theme, for example, a part can represent a line in a border or a label on a button. 
.PP
 
.PP
\fC name \fP\fC [part name] \fP The part's name will be used as reference in the theme's relative positioning system, by programs and in some cases by the application. It must be unique within the group. 
.PP
 
.PP
\fC type \fP\fC [TYPE] \fP Set the type (all caps) from among the available types, it's set to IMAGE by default. Valid types: 
.PD 0

.IP "\(bu" 2
RECT 
.IP "\(bu" 2
TEXT 
.IP "\(bu" 2
IMAGE 
.IP "\(bu" 2
SWALLOW 
.IP "\(bu" 2
TEXTBLOCK 
.IP "\(bu" 2
GRADIENT 
.IP "\(bu" 2
GROUP 
.PP
.PP
 
.PP
\fC mouse_events \fP\fC [1 or 0] \fP Specifies whether the part will emit signals, altought is named 'mouse_events', disabling it (0) will prevent the part from emitting any type of signal at all. Its set to 1 by default. 
.PP
 
.PP
\fC repeat_events \fP\fC [1 or 0] \fP Specifies whether a part echoes a mouse event to other parts below the pointer (1), or not (0). Its set to 0 by default. 
.PP
 
.PP
\fC ignore_flags \fP\fC [FLAG] ... \fP Specifies whether events with the given flags should be ignored, i.e., will not have the signals emitted to the parts. Multiple flags must be separated by spaces, the effect will be ignoring all events with one of the flags specified. Possible flags: 
.PD 0

.IP "\(bu" 2
NONE (default value, no event will be ignored) 
.IP "\(bu" 2
ON_HOLD 
.PP
.PP
 
.PP
\fC scale \fP\fC [1 or 0] \fP Specifies whether the part will scale its size with an edje scaling factor. By default scale is off (0) and the default scale factor is 1.0 - that means no scaling. This would be used to scale properties such as font size, min/max size of the part, and possibly can be used to scale based on DPI of the target device. The reason to be selective is that some things work well being scaled, others do not, so the designer gets to choose what works best. 
.PP
 
.PP
\fC pointer_mode \fP\fC [MODE] \fP Sets the mouse pointer behavior for a given part. The default value is AUTOGRAB. Aviable modes: 
.PD 0

.IP "\(bu" 2
AUTOGRAB, when the part is clicked and the button remains pressed, the part will be the source of all future mouse signals emitted, even outside the object, until the button is released. 
.IP "\(bu" 2
NOGRAB, the effect will be limited to the part's container. container. 
.PP
.PP
 
.PP
\fC precise_is_inside \fP\fC [1 or 0] \fP Enables precise point collision detection for the part, which is more resource intensive. Disabled by default. 
.PP
 
.PP
\fC use_alternate_font_metrics \fP\fC [1 or 0] \fP Only affects text and textblock parts, when enabled Edje will use different size measurement functions. Disabled by default. (note from the author: I don't know what this is exactlu useful for?) 
.PP
 
.PP
\fC clip_to \fP\fC [another part's name] \fP Only renders the area of part that coincides with another part's container. Overflowing content will not be displayed. 
.PP
 
.PP
\fC source \fP\fC [another group's name] \fP Only available to GROUP parts. Swallows the specified group into the part's container. 
.PP
 
.PP
\fC effect \fP\fC [EFFECT] \fP Causes Edje to draw the selected effect among: 
.PD 0

.IP "\(bu" 2
PLAIN 
.IP "\(bu" 2
OUTLINE 
.IP "\(bu" 2
SOFT_OUTLINE 
.IP "\(bu" 2
SHADOW 
.IP "\(bu" 2
SOFT_SHADOW 
.IP "\(bu" 2
OUTLINE_SHADOW 
.IP "\(bu" 2
OUTLINE_SOFT_SHADOW 
.IP "\(bu" 2
FAR_SHADOW 
.IP "\(bu" 2
FAR_SOFT_SHADOW 
.IP "\(bu" 2
GLOW 
.PP
.PP
\fB dragable \fP
.PP
.PP
.nf
        part {
            ..
            dragable {
                confine: 'another part';
                events:  'another dragable part';
                x: 0 0 0;
                y: 0 0 0;
            }
            ..
        }
.fi
.PP
 When this block is used the resulting part can be dragged around the interface, do not confuse with external drag & drop. By default Edje (and most applications) will attempt to use the minimal size possible for a dragable part. If the min property is not set in the description the part will be (most likely) set to 0px width and 0px height, thus invisible. 
.PP
 \fC x \fP\fC [enable/disable] [step] [count] \fP Used to setup dragging events for the X axis. The first parameter is used to enable (1 or -1) and disable (0) dragging along the axis. When enabled, 1 will set the starting point at 0.0 and -1 at 1.0. The second parameter takes any integer and will limit movement to values divisibles by it, causing the part to jump from position to position. The third parameter, (question from the author: What is count for?). 
.PP
 
.PP
\fC y \fP\fC [enable/disable] [step] [count] \fP Used to setup dragging events for the Y axis. The first parameter is used to enable (1 or -1) and disable (0) dragging along the axis. When enabled, 1 will set the starting point at 0.0 and -1 at 1.0. The second parameter takes any integer and will limit movement to values divisibles by it, causing the part to jump from position to position. The third parameter, (question from the author: What is count for?). 
.PP
 
.PP
\fC confine \fP\fC [another part's name] \fP When set, limits the movement of the dragged part to another part's container. 
.PP
 
.PP
\fC events \fP\fC [another dragable part's name] \fP It causes the part to forward the drag events to another part, thus ignoring them for itself. 
.PP
\fB description \fP
.PP
.PP
.nf
        description {
            inherit: 'another_description' INDEX;
            state: 'description_name' INDEX;
            visible: 1;
            min: 0 0;
            max: -1 -1;
            align: 0.5 0.5;
            fixed: 0 0;
            step: 0 0;
            aspect: 1 1;

            rel1 {
                ..
            }

            rel2 {
                ..
            }
        }
.fi
.PP
 Every part can have one or more description blocks. Each description is used to define style and layout properties of a part in a given 'state'. 
.PP
 
.PP
\fC inherit \fP\fC [another description's name] [another description's index] \fP When set, the description will inherit all the properties from the named description. The properties defined in this part will override the inherited properties, reducing the amount of necessary code for simple state changes. Note: inheritance in Edje is single level only. 
.PP
 
.PP
\fC state \fP\fC [a name for the description] [an index] \fP Sets a name used to identify a description inside a given part. Multiple descriptions are used to declare different states of the same part, like 'clicked' or 'invisible'. All states declarations are also coupled with an index number between 0.0 and 1.0. All parts must have at least one description named 'default 0.0'. 
.PP
 
.PP
\fC visible \fP\fC [0 or 1] \fP Takes a boolean value specifying whether part is visible (1) or not (0). Non-visible parts do not emit signals. The default value is 1. 
.PP
 
.PP
\fC align \fP\fC [X axis] [Y axis] \fP When the displayed object's size is smaller than its container, this property moves it relatively along both axis inside its container. The default value is '0.5 0.5'. 
.PP
 
.PP
\fC fixed \fP\fC [width, 0 or 1] [height, 0 or 1] \fP When the 'min' or 'max' properties are set, fixed enables or disables resizing for each dimension. The default value is '0 0' 
.PP
 
.PP
\fC min \fP\fC [width] [height] \fP The minimum size of the state. 
.PP
 
.PP
\fC max \fP\fC [width] [height] \fP The maximum size of the state. 
.PP
 
.PP
\fC step \fP\fC [width] [height] \fP Restricts resizing of each dimension to values divisibles by its value. This causes the part to jump from value to value while resizing. The default value is '0 0' disabling stepping. 
.PP
 
.PP
\fC aspect \fP\fC [min] [max] \fP Normally width and height can be resized to any values independently. The aspect property forces the width to height ratio to be kept between the minimum and maximum set. For example, '1.0 1.0' will increase the width a pixel for every pixel added to heigh. The default value is '0.0 0.0' disabling aspect. 
.PP
 
.PP
\fC aspect_preference \fP\fC [DIMENSION] \fP Sets the scope of the 'aspect' property to a given dimension. Available options are BOTH, VERTICAL, HORIZONTAL and NONE 
.PP
 
.PP
\fC color_class \fP\fC [color class name] \fP The part will use the color values of the named color_class, these values can be overrided by the 'color', 'color2' and 'color3' properties set below. 
.PP
 
.PP
\fC color \fP\fC [red] [green] [blue] [alpha] \fP Sets the main color to the specified values (between 0 and 255). 
.PP
 
.PP
\fC color2 \fP\fC [red] [green] [blue] [alpha] \fP Sets the text shadow color to the specified values (0 to 255). 
.PP
 
.PP
\fC color3 \fP\fC [red] [green] [blue] [alpha] \fP Sets the text outline color to the specified values (0 to 255). 
.PP
\fB rel1/rel2 \fP
.PP
.PP
.nf
        description {
            ..
            rel1 {
                relative: 0.0 0.0;
                offset:     0   0;
            }
            ..
            rel2 {
                relative: 1.0 1.0;
                offset:    -1  -1;
            }
            ..
        }
.fi
.PP
 The rel1 and rel2 blocks are used to define the position of each corner of the part's container. With rel1 being the left-up corner and rel2 being the right-down corner. 
.PP
 \fC relative \fP\fC [X axis] [Y axis] \fP Moves a corner to a relative position inside the container of the relative 'to' part. Values from 0.0 (0%, begining) to 1.0 (100%, end) of each axis. 
.PP
 
.PP
\fC offset \fP\fC [X axis] [Y axis] \fP Affects the corner postion a fixed number of pixels along each axis. 
.PP
 
.PP
\fC to \fP\fC [another part's name] \fP Causes a corner to be positioned relatively to another part's container. 
.PP
 
.PP
\fC to_x \fP\fC [another part's name] \fP Causes a corner to be positioned relatively to the X axis of another part's container. Simply put affects the first parameter of 'relative'. 
.PP
 
.PP
\fC to_y \fP\fC [another part's name] \fP Causes a corner to be positioned relatively to the Y axis of another part's container. Simply put, affects the second parameter of 'relative'. 
.PP
\fB image \fP
.PP
.PP
.nf
        description {
            ..
            image {
                normal: 'filename.ext';
                tween:  'filename2.ext';
                ..
                tween:  'filenameN.ext';
                border:  left right top bottom;
                middle:  0-1;
            }
            ..
        }
.fi
.PP
 
.PP
 \fC normal \fP\fC [image's filename] \fP Name of image to be used as previously declared in the images block. In an animation, this is the first and last image displayed. It's required in any image part 
.PP
 
.PP
\fC tween \fP\fC [image's filename] \fP Name of an image to be used in an animation loop, an image block can have none, one or multiple tween declarations. Images are displayed in the order they are listed. 
.PP
 
.PP
\fC border \fP\fC [left] [right] [top] [bottom] \fP If set, the area (in pixels) of each side of the image will be displayed as a fixed size border, from the side -> inwards, preventing the corners from being changed on a resize. 
.PP
 
.PP
\fC middle \fP\fC [0 or 1] \fP If border is set, this boolean value tells Edje if the rest of the image (not covered by the defined border) will be displayed or not. The default value is 1. 
.PP
\fB fill \fP
.PP
.PP
.nf
        description {
            ..
            fill {
                smooth: 0-1;
                origin {
                    relative: X-axis Y-axis;
                    offset:   X-axis Y-axis;
                }
                size {
                    relative: width  height;
                    offset:   width  height;
                }
            }
            ..
        }
.fi
.PP
 The fill method is an optional block that defines the way an IMAGE or GRADIENT part is going to be displayed inside its container. 
.PP
 \fC smooth \fP\fC [0 or 1] \fP The smooth property takes a boolean value to decide if the image will be smoothed on scaling (1) or not (0). The default value is 1. 
.PP
 
.PP
\fC spread \fP\fC TODO \fP TODO 
.PP
 
.PP
\fC angle \fP\fC TODO \fP TODO 
.PP
 
.PP
\fC type \fP\fC TODO \fP TODO 
.PP
\fB origin \fP
.PP
.PP
.nf
        description {
            ..
            fill {
                ..
                origin {
                    relative: 0.0 0.0;
                    offset:   0   0;
                }
                ..
            }
            ..
        }
.fi
.PP
 The origin block is used to place the starting point, inside the displayed element, that will be used to render the tile. By default, the origin is set at the element's left-up corner. 
.PP
 \fC relative \fP\fC [X axis] [Y axis] \fP Sets the starting point relatively to displayed element's content. 
.PP
 
.PP
\fC offset \fP\fC [X axis] [Y axis] \fP Affects the starting point a fixed number of pixels along each axis. 
.PP
\fB size \fP
.PP
.PP
.nf
        description {
            ..
            fill {
                ..
                size {
                    relative: 1.0 1.0;
                    offset:  -1  -1;
                }
                ..
            }
            ..
        }
.fi
.PP
 The size block defines the tile size of the content that will be displayed. 
.PP
 \fC relative \fP\fC [width] [height] \fP Takes a pair of decimal values that represent the a percentual value of the original size of the element. For example, '0.5 0.5' represents half the size, while '2.0 2.0' represents the double. The default value is '1.0 1.0'. 
.PP
 
.PP
\fC offset \fP\fC [X axis] [Y axis] \fP Affects the size of the tile a fixed number of pixels along each axis. 
.PP
\fB text \fP
.PP
.PP
.nf
        part {
            description {
                ..
                text {
                    text:        'some string of text to display';
                    font:        'font_name';
                    size:         SIZE;
                    text_class:  'class_name';
                    fit:          horizontal vertical;
                    min:          horizontal vertical;
                    max:          horizontal vertical;
                    align:        X-axis     Y-axis;
                    source:      'part_name';
                    text_source: 'text_part_name';
                    elipsis:      0.0-1.0;
                    style:       'stylename';
                }
                ..
            }
        }
.fi
.PP
 
.PP
 \fC text \fP\fC [a string of text, or nothing] \fP Sets the default content of a text part, normally the application is the one changing its value. 
.PP
 
.PP
\fC text_class \fP\fC [text class name] \fP Similar to color_class, this is the name used by the application to alter the font family and size at runtime. 
.PP
 
.PP
\fC font \fP\fC [font alias] \fP This sets the font family to one of the aliases set up in the 'fonts' block. Can be overrided by the application. 
.PP
 
.PP
\fC style \fP\fC [the style name] \fP Causes the part to use the default style and tags defined in the 'style' block with the specified name. 
.PP
 
.PP
\fC size \fP\fC [font size in points (pt)] \fP Sets the default font size for the text part. Can be overrided by the application. 
.PP
 
.PP
\fC fit \fP\fC [horizontal] [vertical] \fP When any of the parameters is set to 1 edje will resize the text for it to fit in it's container. Both are disabled by default. 
.PP
 
.PP
\fC min \fP\fC [horizontal] [vertical] \fP When any of the parameters is enabled (1) it forces the minimum size of the container to be equal to the minimum size of the text. The default value is '0 0'. 
.PP
 
.PP
\fC max \fP\fC [horizontal] [vertical] \fP When any of the parameters is enabled (1) it forces the maximum size of the container to be equal to the maximum size of the text. The default value is '0 0'. 
.PP
 
.PP
\fC align \fP\fC [horizontal] [vertical] \fP Change the position of the point of balance inside the container. The default value is 0.5 0.5. 
.PP
 
.PP
\fC source \fP\fC [another TEXT part's name] \fP Causes the part to use the text properties (like font and size) of another part and update them as they change. 
.PP
 
.PP
\fC text_source \fP\fC [another TEXT part's name] \fP Causes the part to display the text content of another part and update them as they change. 
.PP
 
.PP
\fC text_elipsis \fP\fC [point of balance] \fP Used to balance the text in a relative point from 0.0 to 1.0, this point is the last section of the string to be cut out in case of a resize that is smaller than the text itself. The default value is 0.0. 
.PP
\fB gradient \fP
.PP
.PP
.nf
        part {
            description {
                ..
                gradient {
                    type:    'linear';
                    spectrum 'spectrumName';
                    rel1 {
                        relative: 0.0 0.0;
                        offset:     0   0;
                    }
                    rel2
                        relative: 1.0 1.0;
                        offset:    -1  -1;
                    }
                }
                ..
            }
        }
.fi
.PP
 A gradient block is used to display a given 'spectrum' inside a container. The container's shape is a rect but this not mean the gradient is restricted to a rectangular shape. Gradients can use 'rel1' and 'rel2' blocks to layout the initial and final point relatively inside the container. 
.PP
 \fC type \fP\fC [the name of the type] \fP Alters the gradient's rendering algorithm between: 
.PD 0

.IP "\(bu" 2
linear (default) 
.IP "\(bu" 2
radial 
.PP
.PP
 
.PP
\fC spectrum \fP\fC [an existing spectrum name] \fP Causes the gradient to display the colors as defined by a given 'spectrum' in the 'spectra' block. 
.PP
 
.PP
\fC relative \fP\fC [a relative X coordinate] [a relative Y coordinate] \fP Inside rel1 places the initial point, or first color, of the gradient relatively to the gradient's container. Inside rel2 places the final point, or last color. 
.PP
 
.PP
\fC offset \fP\fC [X axis] [Y axis] \fP Inside rel1 moves the initial point, or first color, of the gradient a fixed number of pixels along either axis. Inside rel2 moves the final point, or last color. 
.PP
\fB program \fP
.PP
.PP
.nf
        group {
            programs {
               ..
                  program {
                     name: 'programname';
                     signal: 'signalname';
                     source: 'partname';
                     in: 0.3 0.0;
                     action: STATE_SET 'statename' state_value;
                     transition: LINEAR 0.5;
                     target: 'partname';
                     target: 'anotherpart';
                     after: 'programname';
                     after: 'anotherprogram';
                  }
               ..
            }
        }
.fi
.PP
 Programs define how your interface reacts to events. Programs can change the state of parts, react to events or trigger other events. 
.PP
 
.PP
\fC name \fP\fC [program name] \fP Symbolic name of program as a unique identifier. 
.PP
 
.PP
\fC signal \fP\fC [signal name] \fP Specifies signal(s) that should cause the program to run. The signal received must match the specified source to run. Signals may be globbed, but only one signal keyword per program may be used. ex: signal: 'mouse,clicked,*'; (clicking any mouse button that matches source starts program). 
.PP
 
.PP
\fC source \fP\fC [source name] \fP Source of accepted signal. Sources may be globbed, but only one source keyword per program may be used. ex:source: 'button-*'; (Signals from any part or program named 'button-*' are accepted) 
.PP
 
.PP
\fC in \fP\fC [from] [range] \fP Wait 'from' seconds before executing the program. And add a random number of seconds (from 0 to 'range') to the total waiting time. 
.PP
 
.PP
\fC action \fP\fC [type] [param1] [param2] \fP Action to be performed by the program. Valid actions are: STATE_SET, ACTION_STOP, SIGNAL_EMIT, DRAG_VAL_SET, DRAG_VAL_STEP and DRAG_VAL_PAGE. Only one action can be specified per program. Examples:
.br
 action: STATE_SET 'statename' 0.5;
.br
 action: ACTION_STOP 'programname';
.br
 action: SIGNAL_EMIT 'signalname' 'emitter'; 
.PP
 
.PP
\fC transition \fP\fC [type] [length] \fP Defines how transistions occur using STATE_SET action.
.br
 Where 'type' is the style of the transistion and 'length' is a double specifying the number of seconds in which to preform the transistion.
.br
 Valid types are: LINEAR, SINUSOIDAL, ACCELERATE, and DECELERATE. 
.PP
 
.PP
\fC target \fP\fC [target] \fP Program or part on which the specified action acts. Multiple target keywords may be specified, one per target. SIGNAL_EMITs do not have targets. 
.PP
 
.PP
\fC after \fP\fC [after] \fP Specifies a program to run after the current program completes. The source and signal parameters of a program run as an 'after' are ignored. Multiple 'after' statements can be specified per program. 
.PP

